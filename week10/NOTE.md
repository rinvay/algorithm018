# 学习笔记-期末总结

在这次的学习过程中，最大的收获就是学习到了正确的学习方法---五毒神掌，以及对动态规划的理解，从望而却步到略有所得，能够自己独立解决一些中等难度的的题目。



## 数据结构

一维：

- 基础：数组，链表
- 高级：栈，队列，双端队列，集合(treeset/hashset)，映射(treetop/hashmap)



二维：

- 基础：树，图
- 高级： 二叉搜索树（红黑树，AVL) ，堆（大顶堆/小顶堆），并查集，字典树



特殊

- 位运算，布隆过滤器
- LRU Cache



常见数据结构操作的时间复杂度

|数据结构|访问|查找|插入|删除|
|---|---|---|---|---|
|数组|O(1)|O(n)|O(n)|O(n)|
|栈|O(n)|O(n)|O(1)|O(1)|
|队列|O(n)|O(n)|O(1)|O(1)|
|链表|O(n)|O(n)|O(1)|O(1)|
|hashmap|-|O(1)|O(1)|O(1)|
|二叉搜索树|O(log(n))|O(log(n))|O(log(n))|O(log(n))|

## 递归，分治，回溯

## 贪心

## 二分查找

## 动态规划

动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法



动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。



通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。



### 适用情况

动态规划常常适用于有**重叠子问题**和**最优子结构**性质的问题，动态规划方法所耗时间往往远少于朴素解法。



1. 最优子结构性质。**如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）**。最优子结构性质为动态规划算法解决问题提供了重要线索。或者说，**问题的最优解能通过子问题的最优解推导得到（一般是简单计算）。**
2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。



### 关键点

1. 重复子问题，最优子结构
2. 状态表示
3. 状态转移方程（数学归纳法）



### 贪心、分治、回溯和动态规划的联系和区别



如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类。因为它跟其它三个都不大一样。为什么这么说呢？前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。



回溯算法是个“万金油”。基本上能用动态规划、贪心解决问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得出最优解。不过，回溯算法的时间复杂度非常高，只能用来解决小规模数据问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。



尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、后后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反。动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。



贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现再加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。



其中，最优子结构、无后效性跟动态规划中的无异。“贪心选择性”的意思是，通过局部最优的选择，能产生全局最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有的阶段的决策完成之后，最终由些局部最优解构成全局最优解。